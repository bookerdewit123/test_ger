#                  PAC-3 - MSE (with uplink and seeker)
#Ref 1 - his PAC-3 representation extends upon the baseline seeker representation
# by providing a datalink and a seeker.
#
# References:
#
#    http://www.globalsecurity.org/space/systems/patriot-ac-3.htm
#
#    "The missile flies to an intercept point specified prior to launch by its
#    ground-based fire solution computer, which is embedded in the engagement
#    control station. Target trajectory data can be updated during missile flyout
#    by means of a radio frequency uplink/downlink. Shortly before arrival at the
#    intercept point, the PAC-3 Missile's on board Ka band seeker acquires the
#    target, selects the optimal aim point and terminal guidance is initiated.
#    The ACMs, which are small, short duration solid propellant rocket motors
#    located in the missile forebody, fire explosively to refine the missile's
#    course to assure body-to-body impact.
#
#Ref 2 - (PDF files contained in the subdirectory pac-3_ref)
#    Jane's JLAD Patriot PAC-3, 21-May-2009
#    Diameter: .255 m, Length 5.205
#    Mass: 315 kg for PAC-3, 312 kg for PAC-3 MSE
#    Max Speed: 1700 m/s for PAC-3, >1700 m/s for PAC-3 MSE
#    Max Range: 15 km for PAC-3, 35 km for PAC-3 MSE against ballistic
#                                100km for PAC-3 MSE agaist aerial targets         
#
#Ref 3 - http://en.wikipedia.org/wiki/MIM-104_Patriot
#    'The system's missiles are transported on and launched from the M901
#    Launching Station, which can carry up to four PAC-2 missiles or up to
#    sixteen PAC-3 missiles.'
#
# *********************************************************************************************** #
###############################################################################
#
# NOTE: If you modify any parameter in this file, you must rerun 'weapon_tools'
#       with 'pac-3_lcg.txt' as input to regenerate the launch computer data.
#
###############################################################################

include_once weapons/blue/launch_computers/pac-3_mse_script_launch_computer.txt

# Signature data is unknown...

infrared_signature PAC-3_INFRARED_SIGNATURE
   constant 1 watts/steradian
end_infrared_signature

optical_signature  PAC-3_OPTICAL_SIGNATURE
   constant 1 m^2
end_optical_signature

radar_signature    PAC-3_RADAR_SIGNATURE
   constant 1 m^2
end_radar_signature

# Nominal lethality data.
weapon_effects PAC-3_EFFECT WSF_GRADUATED_LETHALITY
   radius_and_pk 100.0 m 0.95

   # This script will reduce the effectiveness if the impact geometry is not desirable.

#   script void on_weapon_target_engagement(WsfPlatform aTarget)
#      WsfPlatform weapon = WeaponPlatform();
#      if (! (aTarget.IsValid() && weapon.IsValid())) return;
#
#      // Compute the angle between the velocity vectors. A head-on hit would be 180 degrees.
#      // (velocity vectors in opposite directions).
#      Vec3 weaponVel = weapon.VelocityWCS();
#      Vec3 targetVel = aTarget.VelocityWCS();
#      double weaponVelMag = weaponVel.Magnitude();
#      double targetVelMag = targetVel.Magnitude();
#      if ((weaponVelMag > 1.0) && (targetVelMag > 1.0))
#      {
#         double cosAngle = Vec3.Dot(weaponVel, targetVel) / (weaponVelMag * targetVelMag);
#         if (cosAngle < -1.0) cosAngle = -1.0;
#         if (cosAngle >  1.0) cosAngle =  1.0;
#         double angle = Math.ACos(cosAngle);
#         #writeln("Angle=", angle);
#         //TODO if (angle < xxx) SetPkDegrade(0.6);
#      }
#   end_script

end_weapon_effects

###############################################################################

aero PAC-3_AERO WSF_AERO
   reference_area            0.0510705 m2        # Ref 1, 0.255 m diameter
   aspect_ratio              2.0
   cl_max                    4.5
   cl_max                    20.0                # TODO-TEST

   # Values estimated from Hoerner's Drag book
   cd_zero_subsonic          0.10
   cd_zero_supersonic        0.35
   mach_begin_cd_rise        0.95
   mach_end_cd_rise          1.30
   mach_max_supersonic       6.00
end_aero

mover PAC-3_MOVER WSF_GUIDED_MOVER
   integration_timestep      0.001 secs
   update_interval           0.01 secs

   stage 1
      aero                   PAC-3_AERO
      total_mass             315 kg              # Ref 1

#     Ref 2 defines the warhead to be 73 kg
#     Add another 20% of remaining mass for structure. (Space Shuttle SRB is
#     about 15% structure, but we're making it 20% to account for higher G's.
#
#     315 kg - 73 kg = 242 kg
#     242 kg * 0.2   = 48.4 kg
#     So empty mass = 73 + 48 = 121.4 kg

      empty_mass             121.4 kg            # See calculations above
      specific_impulse       250 sec             # Nominal solid rocket
      burn_time              13 sec              # Estimated to get speed ~= 1700 m/s
   end_stage

end_mover

###############################################################################

processor PAC-3_GUIDANCE WSF_GUIDANCE_COMPUTER
   # No datalink or seeker is being used, so we must guide to the true target
   guide_to_truth                      true

   phase LAUNCH
      guidance_delay                   100.0 sec
      next_phase PITCH_OVER when phase_time >= 0.1 sec
   end_phase

   phase PITCH_OVER
      #commanded_flight_path_angle      from_launch_computer
      proportional_navigation_gain     0.0                 # Don't guide to target
      velocity_pursuit_gain            0.0                 # Don't guide to target
      maximum_commanded_g              20.0 g
      next_phase MIDCOURSE when phase_time > 3 sec
   end_phase
   
   phase MIDCOURSE
      guidance_delay                   1000.0 sec
      
      # Identify what type of threat via altitude, and guide accordingly
      next_phase MIDCOURSE_AIR_BREATHER if target_altitude < 35000 m
      next_phase MIDCOURSE_BALLISTIC if target_altitude >= 35000 m
   end_phase
   
   phase MIDCOURSE_AIR_BREATHER
      # no guidance (just use gravity turn)
      guidance_delay                   1000.0 sec
      
      next_phase PRE_TERMINAL when time_to_intercept < 10.0 sec
      next_phase PRE_TERMINAL when range_to_intercept < 30 km  #time_to_intercept < 1.0 sec
   end_phase
   
   phase MIDCOURSE_BALLISTIC
      # no guidance (just use gravity turn)
      guidance_delay                   1000.0 sec
      next_phase NEAR_TERMINAL when range_to_intercept < 10 km  #time_to_intercept < 1.0 sec
   end_phase
   
   phase PRE_TERMINAL
      proportional_navigation_gain    1.0
      proportional_navigation_method   pure
#      guidance_target predicted_intercept

      # Disable velocity pursuit. The angle which controls the switch between
      # velocity pursuit and pronav are too sensitive at short ranges.
      velocity_pursuit_gain            5.0

      # Disable g-bias. The target is also falling, so we don't want to fight
      # against it! (this is assuming terminal intercept, not boost)
      g_bias                           0.0
      next_phase TERMINAL when range_to_intercept < 25 km  #time_to_intercept < 1.0 sec
   end_phase
   
   phase TERMINAL
      proportional_navigation_gain     2.0
      proportional_navigation_method   pure
#      guidance_target predicted_intercept

      # Disable velocity pursuit. The angle which controls the switch between
      # velocity pursuit and pronav are too sensitive at short ranges.
      velocity_pursuit_gain            2.0

      # Disable g-bias. The target is also falling, so we don't want to fight
      # against it! (this is assuming terminal intercept, not boost)
      g_bias                           0.0
      next_phase NEAR_TERMINAL when range_to_intercept < 10 km  #time_to_intercept < 1.0 sec
   end_phase

   phase NEAR_TERMINAL
      proportional_navigation_gain     5.0
      proportional_navigation_method   pure
      proportional_navigation_limit_angle  90 deg
#      guidance_target predicted_intercept

      # Disable velocity pursuit. The angle which controls the switch between
      # velocity pursuit and pronav are too sensitive at short ranges.
      velocity_pursuit_gain            0.0

      # Disable g-bias. The target is also falling, so we don't want to fight
      # against it! (this is assuming terminal intercept, not boost)
      g_bias                           0.0
   end_phase
end_processor

###############################################################################

#platform_type PAC-3_BASE WSF_PLATFORM
#
#  infrared_signature PAC-3_INFRARED_SIGNATURE
#  optical_signature  PAC-3_OPTICAL_SIGNATURE
#  icon SA-10_Missile  # (PAC-3 icon is not available)
#  radar_signature    PAC-3_RADAR_SIGNATURE
#
#  processor guidance PAC-3_GUIDANCE
#     #show_status
#     #show_graphics
#
#  weapon_effects     PAC-3_EFFECT
#
#  mover PAC-3_MOVER
#     #show_status
#     #time_history_path .
#  end_mover
#  end_processor
#
#  processor fuse WSF_AIR_TARGET_FUSE
#     detonate_below_mach 1.0
#
#     # The following are used to limit the run time during launch computer
#     # generation. They can be removed for real simulation use if one really
#     # wants to see the missile do something after a big miss.
#
#     detonate_above_height_msl      35 km
#     max_time_of_flight_to_detonate 80 sec
#  end_processor
#end_platform_type

###############################################################################

#launch_computer PAC-3_LAUNCH_COMPUTER WSF_OUTMATCH_LAUNCH_COMPUTER # WSF_BALLISTIC_MISSILE_LAUNCH_COMPUTER
#   surface_to_air_table      pac_launch_data.txt 
#   integration_time_step     0.05 sec
#
#   maximum_intercept_altitude   80 km
#   minimum_intercept_altitude   2 km
#
#   maximum_intercept_angle   60 deg
#   #show_graphics
#   range_color                       "c56BD5ff"
#
#end_launch_computer

launch_computer PAC-3_LAUNCH_COMPUTER PAC-3_MSE_SCRIPT_LAUNCH_COMPUTER # WSF_BALLISTIC_MISSILE_LAUNCH_COMPUTER
end_launch_computer

###############################################################################

weapon PAC-3 WSF_EXPLICIT_WEAPON

   # The location offset puts the weapon center at half the length - 1 m.
   # This assumes the scenario creator puts the launching platform at 1 m agl.

   #location 0.0 0.0 -1.6025 m                    # Ref 1, length = 5.205 m

   launched_platform_type PAC-3

   launch_computer PAC-3_LAUNCH_COMPUTER
   end_launch_computer

   tilt 35 deg

   # This causes a call to the launch computer to compute the predicted intercept.
   # The launcher will then be cued to the proper angles (Subject to the slewing
   # limits defined below). This is a bit of a hack until the guidance computer
   # is changed...

#   cue_to_predicted_intercept true
#   slew_mode azimuth
#   azimuth_slew_limits -180 deg 180 deg

   quantity 16                                   # Ref 2

end_weapon


# include weapons/sam/pac-3_common.txt
#TO DO: Make the missile as simple as possible, many things might be required for the BMS to operate so be careful. But more of a 
#staight line mover is likely desired. Unless customer is OK with the guidance we have in place
###############################################################################

platform_type PAC-3 WSF_PLATFORM #PAC-3_BASE

  icon pac-3_missile 

  infrared_signature PAC-3_INFRARED_SIGNATURE
  optical_signature  PAC-3_OPTICAL_SIGNATURE
  radar_signature    PAC-3_RADAR_SIGNATURE

  weapon_effects     PAC-3_EFFECT

  mover PAC-3_MOVER
     #show_status
     #time_history_path .
  end_mover

  processor guidance PAC-3_GUIDANCE
     #show_status
     #show_graphics
  end_processor

  processor fuse WSF_AIR_TARGET_FUSE
     #detonate_below_mach 1.0

     # The following are used to limit the run time during launch computer
     # generation. They can be removed for real simulation use if one really
     # wants to see the missile do something after a big miss.
     gross_proximity_range 300 m
     detonate_above_height_msl      35 km
     max_time_of_flight_to_detonate 300 sec
  end_processor

   processor track_mgr WSF_TRACK_PROCESSOR 
      # Created by: Ryan Fisher
      # Creation date: 10/21/2022
      # Description:
      #   This processor instantiates a TrackManager on the weapon, allowing
      #   for the 'receive_track_message' processor to add tracks for the 
      #   weapon. This allows us to avoid using the "WSF_PERFECT_TRACKER",
      #   at least until we are close to the target.
      update_interval 0.1 second # Update interval should corrspond to launcher
   end_processor
   
   processor receive_track_message WSF_MESSAGE_PROCESSOR
      # Created by: Ryan Fisher
      # Creation date: 10/21/2022
      # Description: 
      #   This processer provides a means of receiving a track from the weapon's 
      #   corresponding launcher. On receipt of a message, typed "TrackMessage", 
      #   the script adds the track associated with the message to the TrackManager
      #   via AddTrackReport. This updates any existing corresponding tracks on 
      #   the track manager.
      #   The message size is set to zero bits, however, a latency factor can be
      #   enforced in the comms via 'packet_loss_time'. 
      #
      #   Dependency: see the need for 'internal_link receive_track_message' so the
      #      processor can receive the message from the comm system.
      #
      #   Note: this feature is combined with the "message_draw
      on
      script_variables 
         WsfTrackManager weaponTrackManager = PLATFORM.TrackManager(); # Get the weapon's TrackManager
      end_script_variables
      
      on_message 
         type TrackMessage # Execute script only if message of type TrackMessage
         script            
            WsfTrackMessage trackMessage = (WsfTrackMessage)MESSAGE; # Cast the message as a WsfTrackMessage
            weaponTrackManager.AddTrackReport(trackMessage.Track()); # Get the track in the message, and add to TrackManager
            ### Write MessageID received and time to receive, calculated based on message ID. 
            if ($<IBCS_VERBOSE:true>$) writeln(TIME_NOW, " MessageID: ", trackMessage.AuxDataDouble("MessageID")," time to receive: ", ((TIME_NOW*1000 - trackMessage.AuxDataDouble("MessageID"))/1000));
         end_script
      end_on_message
   end_processor
   
   processor message_draw WSF_MESSAGE_PROCESSOR
      # Created by: Ryan Fisher
      # Creation date: 10/21/2022
      # Description: 
      #   This processer provides a means of receiving a track from the weapon's 
      #   corresponding launcher. On receipt of a message, typed "TrackMessage", 
      #   the script adds the track associated with the message to the TrackManager
      #   via AddTrackReport. This updates any existing corresponding tracks on 
      #   the track manager.
      #   The message size is set to zero bits, however, a latency factor can be
      #   enforced in the comms via 'packet_loss_time'. 
      #
      #   Note: this feature is combined with the "message_draw
      on
      script_debug_writes off
      script_variables 
         WsfDraw mDraw = WsfDraw();
         WsfTrackManager weaponTrackManager = PLATFORM.TrackManager(); # Get the weapon's TrackManager
        #extern bool drawUplinks;
      end_script_variables
      
#      on_message 
#         type TrackMessage
#         script            
#            WsfTrackMessage trackMessage = (WsfTrackMessage)MESSAGE;
#            #writeln("Received a message at time: ", TIME_NOW, " MessageID: ", trackMessage.AuxDataDouble("MessageID"));
#            weaponTrackManager.AddTrackReport(trackMessage.Track());
#            writeln("Time to receive: ", ((TIME_NOW*1000 - trackMessage.AuxDataDouble("MessageID"))/1000));
#         end_script
#      end_on_message
#      on_message 
#         script
#            if (drawUplinks)
#            {
#               #writeln_d(WriteTime(TIME_NOW),PLATFORM.Name()," received a message of type ",MESSAGE.Type()," from ",MESSAGE.Originator()); 
#               if(MESSAGE.Type() == "WSF_TRACK_MESSAGE")
#               {
#                  WsfPlatform sender = WsfSimulation.FindPlatform(MESSAGE.Originator());
##                  if (enableDrawing && sender.IsValid() && PLATFORM.CommanderName() == sender.Name())
##                  {
##                     mDraw.SetLayer("uplink_lines");
##                     mDraw.SetLineStyle("dashed");
##                     mDraw.SetDuration(1);
##                     mDraw.SetLineSize(3);
##                     mDraw.SetColor(0,1,1);
##                     mDraw.BeginLines();
##                     mDraw.Vertex(sender);
##                     mDraw.Vertex(PLATFORM);
##                     mDraw.End(); 
##                  }
#               }
#            } 
#         end_script
#      end_on_message
   end_processor

#   comm uplink WEAPONUPLINK #GENERIC_DATALINK
#      network_name weapon_net
##      internal_link message_draw
##      internal_link receive_track_message # Internal link here 
##      #internal_link perception
##      internal_link track_mgr
#   end_comm

   # The seeker is modeled very simplisticly. There is no performance data.
   # This is really just a method to model seeker errors.

   sensor seeker WSF_GEOMETRIC_SENSOR
      off

      frame_time                       0.1 sec

      azimuth_field_of_view            -70 deg 70 deg
      elevation_field_of_view          -70 deg 70 deg
      maximum_range                    50 km

      maximum_request_count            1

      range_error_sigma                1 m
      azimuth_error_sigma              0.001 deg
      elevation_error_sigma            0.001 deg

      filter                           WSF_KALMAN_FILTER
         process_noise_sigmas_XYZ      50 50 50
         process_noise_model           constant_acceleration
      end_filter

      reports_range
      reports_bearing
      reports_elevation
      reports_velocity

      internal_link data_mgr
   end_sensor

   processor data_mgr WSF_WEAPON_TRACK_PROCESSOR
   end_processor

   # Modify the guidance processor such that when it enters TERMINAL phase
   # that it turns on the sensor and starts tracking the target. During this
   # phase we guide to perception to allow the introduction of errors.

   edit processor guidance
   
      edit phase TERMINAL
         #guide_to_truth false

         on_entry
            WsfSensor seeker = PLATFORM.Sensor("seeker");
            WsfTrack targetTrack = PLATFORM.CurrentTargetTrack();
            if (seeker.IsValid() &&
                targetTrack.IsValid())
            {
               seeker.TurnOn();
               seeker.StartTracking(targetTrack, "");
            }
         end_on_entry
      end_phase
   end_processor

end_platform_type