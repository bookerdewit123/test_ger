include_once CommMessage.txt
include_once CommNetwork.txt
include_once CommLink.txt 
include_once CommManagerObserver.txt
include_once observers_aims/CsvLogFileManager.txt
include_once utils/G425/JammerManager.txt

# The CommManager is a "singleton-like" manager for the comm model for the
# G425 effort. Use the global CommManagerInstance() method to access the
# single instance of the manager.
script_struct CommManager
   script_variables
      # The name of the global script used to initialize the CommManager. An implementation
      # of this script is required and is scenario specific. 
      string cDEFINE_COMM_NETWORKS_SCRIPT_NAME = "DefineCommNetworks";
      
      # Tracks the initialization state of the CommManager. See the Initialize()
      # method for more details
      bool mIsInitialized = false;

      # Storage for the registered Comm Networks 
      Map<string, CommNetwork> mCommNetworks = Map<string, CommNetwork>();
      
      # Storage for Commlinks, optimized for quick lookups using Map keys
      # Source -> MessageName -> CommLink: Target(s) 
      Map<WsfPlatform, Map<string, Map<CommNetwork, Set<WsfPlatform>>>> mCommLinksBySource =
         Map<WsfPlatform, Map<string, Map<CommNetwork, Set<WsfPlatform>>>>();

      string cCOMM_MANAGER_LOG_FILE_NAME = "CommManager";
      
      # This map stores a list of which platform have received which messages. This is used to
      # support the sending of braodcast messages 
      Map<int, Set<WsfPlatform>> mMessageReceivedBy = Map<int, Set<WsfPlatform>>();
   end_script_variables
   
   # Returns the set of platforms that have already received a message with the given id
   #
   # param aId The message id
   script Set<WsfPlatform> GetReceiversOfMessage(int aId) {
      if(!mMessageReceivedBy.Exists(aId))
         mMessageReceivedBy.Set(aId, Set<WsfPlatform>());
      
      return mMessageReceivedBy.Get(aId);
   }
   end_script
   
   # Attempts to register a CommNetwork
   #
   # param aNetwork     The configuration of the network
   # return             True if a network with the given name has not already been registered, otherwise False 
   script bool RegisterCommNetwork(CommNetwork aNetwork)
      string networkname = aNetwork.GetName();
      if (mCommNetworks.Exists(networkname))
         return false;
      
      mCommNetworks.Set(networkname, aNetwork);
      return true;
   end_script
  
   # Adds a CommLink beweent two platforms
   #
   # param aSourcePlatform  The "source" platform for the message link.
   # param aTargetPlatform  The "target" platform for the message link.
   # param aCommNetwork     The configuration of the network for the link.
   # param aMessageTypes    The message types to be sent on the link.
   # return                 True if the CommLink was added, otherwise False 
   script bool AddCommLink( WsfPlatform aSourcePlatform, 
                            WsfPlatform aTargetPlatform, 
                            CommNetwork aCommNetwork, 
                            Set<string> aMessageTypes) {
      string console_msg =
         "      Adding Comm Link from " +
         aSourcePlatform.Name() + " to " +
         aTargetPlatform.Name() + " for message types: ";
      SetIterator iter = aMessageTypes.GetIterator();
      while(iter.HasNext()) {
         if(iter.HasPrev())
            console_msg += ", ";
         iter.Next();
         console_msg += (string)iter.Data();            
      }
      writeln(console_msg);
      
      # Create and store the commLink
      CommLink commLink = ConstructCommLink( aSourcePlatform, aTargetPlatform, aCommNetwork, aMessageTypes );
      
      if(!mCommLinksBySource.Exists(aSourcePlatform)) {
         mCommLinksBySource.Set(aSourcePlatform, Map<string, Map<CommNetwork, Set<WsfPlatform>>>());
      }
      
      Map<string, Map<CommNetwork, Set<WsfPlatform>>> messageMap =
         mCommLinksBySource.Get(aSourcePlatform);
      
      foreach( string messageType in aMessageTypes ) {
         if (!messageMap.Exists(messageType)) {
            messageMap.Set(messageType, Map<CommNetwork, Set<WsfPlatform>>());
         }
         
         Map<CommNetwork, Set<WsfPlatform>> targetAndLinksMap =
            messageMap.Get(messageType);
         
         if(!targetAndLinksMap.Exists(aCommNetwork)){
            targetAndLinksMap.Set(aCommNetwork, { aTargetPlatform });
         } else {
            targetAndLinksMap.Get(aCommNetwork).Insert( aTargetPlatform );
         }
         
      }
      
      return true;
   }
   end_script

   # This method will be invoked when the SIMULATION_STARTING event is observed by the
   # CommManagerObserver. If for some reason the observer does not invoke Initialize(),
   # then it will be invoked the first time that a message is sent.
   # Initalize() attempts to invoke an initializer script if one was provided. (Note:
   # If one is not given communications will not work as this initializer defines the
   # comm networks)
   script void Initialize()
      if(!mIsInitialized) {
         writeln("Initializing CommManager");
      
         
         # Attempt to invoke the laydown specific script which defines the mCommNetworks
         writeln("Attempting to invoke the global script, " + cDEFINE_COMM_NETWORKS_SCRIPT_NAME);
         assert( WsfSimulation.ScriptExists(cDEFINE_COMM_NETWORKS_SCRIPT_NAME),
                 "The Comm Manager is unable to locate the global script: " + cDEFINE_COMM_NETWORKS_SCRIPT_NAME);
         Array<CommNetwork> commNetworks =
            (Array<CommNetwork>)WsfSimulation.Execute(cDEFINE_COMM_NETWORKS_SCRIPT_NAME);
         assert( !commNetworks.IsNull(),
                 "The global script " + cDEFINE_COMM_NETWORKS_SCRIPT_NAME + " returned null"); 
         
         # Iterate over the comm networks and register them
         writeln("Registering CommNetworks");
         foreach (CommNetwork commNetwork in commNetworks)
         {
            writeln("  Registering CommNetwork: " + commNetwork.GetName());
            assert( RegisterCommNetwork(commNetwork),
                    "The Comm manager was unable to register the Comm Network: " + commNetwork.GetName()); 
         }
         
         # Iterate over the platforms and register their comm links
         writeln("Creating CommLinks");
         for (int i = 0; i < WsfSimulation.PlatformCount(); i = i + 1)
         {
            WsfPlatform source = WsfSimulation.PlatformEntry(i);
            if( source.IsA_TypeOf("G425_PLATFORM_BASE") &&
                !source->messageLinks.IsNull()) {
               Array<Map<string, Object>> linkDefinitions = source->messageLinks;
               writeln("  Found [" + (string)linkDefinitions.Size() + "] Comm Links for source platform " + source.Name());
               foreach (Map<string, Object> linkDefinition in linkDefinitions) {
                  # Retrieve link definition data for the network 
                  string networkName = (string)linkDefinition.Get("network");
                  assert( mCommNetworks.Exists(networkName),
                          "Unable to create comm link. Comm network " + networkName + " was not registered");
                  CommNetwork network = mCommNetworks.Get(networkName);

                  # Retrieve link definition data for the target 
                  string targetName = (string)linkDefinition.Get("target");
                  WsfPlatform target = WsfSimulation.FindPlatform(targetName);
                  assert( target.IsValid(), 
                          "Unable to find platform named " + targetName + " in the scenario"); 

                  # Retrieve link definition data for the messages 
                  Array<Object> messageNameObjects = (Array<Object>)linkDefinition.Get("messages");
                  Set<string> messageNames = Set<string>();
                  if(!messageNameObjects.IsNull()) {
                     foreach (Object messageName in messageNameObjects) {
                        messageNames.Insert((string)messageName);
                     }
                  }

                  # Retrieve link definition data for the link direction 
                  string direction = (string)linkDefinition.Get("direction");
                  if(direction.Length() == 0)
                     direction = "bi-directional";

                  writeln("    Link[" + direction + "] to " + target.Name() + " on " + networkName + " for: [" + messageNames.ToString() + "]");

                  # Create the CommLink(s)
                  if(direction == "bi-directional" || direction == "forward") {
                     assert( AddCommLink( source, target, network, messageNames) );
                  }
                  if(direction == "bi-directional" || direction == "reverse") {
                     assert( AddCommLink( target, source, network, messageNames) );
                  }                     
               }
            }
         }
         CSV_DATA_TYPES csvDataTypes = CSV_DATA_TYPES();
         # Initialize log file header with names and types (Note: may want to create a manager for this for validation)
         Array<string> header_names = {
            "SendTime",
            "ReceiveTime",
            "Type",
            "MessageID",
            "MessageType",
            "MessageSubType",
            "MessageAge",
            "Transmitter",
            "CommsType",
            "Receiver",
            "FailureReason",
            "Route"
         };
         Array<string> header_types = {
            csvDataTypes.cDECIMAL_TYPE,
            csvDataTypes.cDECIMAL_TYPE,
            csvDataTypes.cSTRING_TYPE,
            csvDataTypes.cINT_TYPE,
            csvDataTypes.cSTRING_TYPE,
            csvDataTypes.cSTRING_TYPE,
            csvDataTypes.cDECIMAL_TYPE,
            csvDataTypes.cSTRING_TYPE,
            csvDataTypes.cSTRING_TYPE,
            csvDataTypes.cSTRING_TYPE,
            csvDataTypes.cSTRING_TYPE,
            csvDataTypes.cSTRING_TYPE
         };

         CSVLogFileManagerInstance().CreateLogFile(cCOMM_MANAGER_LOG_FILE_NAME, header_names, header_types);
         #Disallow reinitialization
         mIsInitialized=true;
      }
   end_script
   
   # Appends a new line to the csv output file describing a message that was
   # sent on a comm network.
   #
   # param aSendTime    The simulation time when the message was created
   # param aReceiveTime The simulation at which time the message will be handled by the target platform
   # param aCommMessage The CommMessage sent
   # param aCommNetwork The CommNetwork the message on which the message was sent 
   script void LogCommMessage( double aSendTime, 
                               double aReceiveTime,
                               CommMessage aCommMessage,
                               CommNetwork aCommNetwork,
                               string aType,
                               string failureReason ) {
                               
      Array<string> fields = {
         (string)aSendTime,
         (string)aReceiveTime,
         aType,
         (string)aCommMessage.GetId(),
         aCommMessage.GetMessage().Type(),
         aCommMessage.GetMessage().SubType(),
         (string)( aSendTime - aCommMessage.GetMessageCreationTime() ),
         aCommMessage.GetSourcePlatform().Name(),
         aCommNetwork.GetName(),
         aCommMessage.GetTargetPlatform().Name(),
         failureReason,
         "->".Join(aCommMessage.GetRoute())
      };
      CSVLogFileManagerInstance().LogToFile(cCOMM_MANAGER_LOG_FILE_NAME, fields);
   }
   end_script

   script void markMessageAsReceivedByPlatform(int aMessageId, WsfPlatform aPlatform) {
      Set<WsfPlatform> receiversOfMessage = GetReceiversOfMessage(aMessageId);
      if( receiversOfMessage.Exists(aPlatform) )
         return;
   
      # Mark that this platform has handled/repeated the message
      receiversOfMessage.Insert(aPlatform);
   }
   end_script
   
   # Attempts to send a message out from a source platform to all other
   # platforms to which it is linked.
   #
   # param aCommMessage  The message to be sent. It will be copied, retaining the
   #                     original id. The copies will update the target to a linked
   #                     target as the links are iterated
   # return  false if any link was unable to handle the message, else true   
   script bool SendMessageOnAllLinks( CommMessage aCommMessage ) {
      double timeNow = aCommMessage.GetMessageHandlingTime();
      WsfPlatform sourcePlatform = aCommMessage.GetSourcePlatform();
      
      if(!mCommLinksBySource.Exists(sourcePlatform))
         return false;
      
      Map<string, Map<CommNetwork, Set<WsfPlatform>>> messageMap =
         mCommLinksBySource.Get(sourcePlatform);
      
      string messageType = aCommMessage.GetMessage().Type();
      if (!messageMap.Exists(messageType))
         return false;
         
      Map<CommNetwork, Set<WsfPlatform>> linkAndTargets =
         messageMap.Get(messageType);

      if (linkAndTargets.Empty())
         return false;
         
      bool retVal = true;
      # Handling for point-to-point messages 
      foreach ( CommNetwork commNetwork : Set<WsfPlatform> targetPlatforms in linkAndTargets ) {
         foreach ( WsfPlatform targetPlatform in targetPlatforms ) {
            # If the target of this link was destroyed then skip sending the message 
            if(targetPlatform.IsNull())
               continue;
               
            # Verify that the comm message handler script defined by the platform exists
            string handlerScriptName = targetPlatform->GetMessageHandlerScriptName();
            if(!WsfSimulation.ScriptExists(handlerScriptName)) {
               # TODO log error
               retVal = false;
               continue; 
            }         

            # Generate a delay based on the registered comm links configuration
            double delay = commNetwork.GenerateDelay();
            double executionTime = timeNow + delay;

            # Create and dispatch the commMessage
            CommMessage commMessage =
               ConstructCommMessageCopy(aCommMessage, executionTime, sourcePlatform, targetPlatform);
            
            # Check if commMessage is over Link16 and if target platform is jammed
            # if so, do not call ExecuteAtTime and log failure reason as "jammed"
            bool sourceIsJammed = JammerManagerInstance().IsLocationJammed(sourcePlatform.Location(), commNetwork.GetName());
            bool targetIsJammed = JammerManagerInstance().IsLocationJammed(targetPlatform.Location(), commNetwork.GetName());
            if( sourceIsJammed || targetIsJammed ) { 
               if ( sourceIsJammed && targetIsJammed ){
                  LogCommMessage( timeNow, executionTime, commMessage, commNetwork, "SEND", "Both Jammed");   
               } else if ( sourceIsJammed ) {
                  LogCommMessage( timeNow, executionTime, commMessage, commNetwork, "SEND", "Transmitter Jammed");
               } else {
                  LogCommMessage( timeNow, executionTime, commMessage, commNetwork, "SEND", "Receiver Jammed");
               }
            } else {
               WsfSimulation.ExecuteAtTime( executionTime, handlerScriptName, {commMessage});
               # Log the message to the csv
               LogCommMessage( timeNow, executionTime, commMessage, commNetwork, "SEND", "");   
            }                     
         }
      }
      return retVal;   
   }
   end_script

   # Handles the repetition of a broadcast message. This will send the CommMessage
   # out on all links except for any links back to the source platform. It also tracks
   # if a platform has already received the message and prevents from repeating the
   # message to a platform that has already received it.
   #
   # param  aCommMessage  The message to be sent. It will be copied, retaining the
   #                      original id. The copies will update the target to a linked
   #                      target as the links are iterated
   # return  false if any link was unable to handle the message, else true         
   script bool RepeatBroadcastMessage( CommMessage aCommMessage ) {
      # This should never happen, but just in case...
      if(!mIsInitialized)
         Initialize();

      # Get the set of platforms that have already received this message 
      Set<WsfPlatform> receiversOfMessage = GetReceiversOfMessage(aCommMessage.GetId());

      WsfPlatform repeatingPlatform = null;
      if(aCommMessage.GetHopCount() == 0 ) {
         # If this is the first transmission of a message, then Hop Count will be 0.
         # In this case the target has not been set and the message is being "repeated"
         # by the source platform
         repeatingPlatform = aCommMessage.GetSourcePlatform();
      } else {
         # If this is an actual repeat then hop count will be greater than zero
         # In this case, the repeating platform is the target of the incoming message         
         repeatingPlatform = aCommMessage.GetTargetPlatform();

         # Has this repeating platform been destroyed?
         if(repeatingPlatform.IsNull())
            return false;

         # Has this repeating platform already received/handled this message?
         if( receiversOfMessage.Exists(repeatingPlatform) )
            return false;
      }
      
      # Mark this message as "received" meaning no other platform should try to the send this
      # message back to this platform 
      markMessageAsReceivedByPlatform( aCommMessage.GetId(), repeatingPlatform );

      
      # Does the repeater have links
      if(!mCommLinksBySource.Exists(repeatingPlatform))
         return false;
      
      # Get them
      Map<string, Map<CommNetwork, Set<WsfPlatform>>> messageMap =
         mCommLinksBySource.Get(repeatingPlatform);      
      
      # The current time is the timestamp on the CommMessage
      double timeNow = aCommMessage.GetMessageHandlingTime();
      
      # Do any of the repeaters links support this message type?
      string messageType = aCommMessage.GetMessage().Type();
      if (!messageMap.Exists(messageType))
         return false;
      
      # Get Them
      Map<CommNetwork, Set<WsfPlatform>> linkAndTargets =
         messageMap.Get(messageType);      
      
      # Repeat the message out on those links
      bool retVal = true;
      foreach ( CommNetwork commNetwork : Set<WsfPlatform> targetPlatforms in linkAndTargets ) {
         foreach ( WsfPlatform targetPlatform in targetPlatforms ) {
            # If the target of this link was destroyed then skip sending the message 
            if(targetPlatform.IsNull())
               continue;
               
            # If this target is the source of the repeated message, then do
            # not repeat the message back to it
            if( targetPlatform == aCommMessage.GetSourcePlatform() )
               continue;
            
            # If this target has already received the message, then don't send it
            # Note: This is an optimization to reduce the number of redundant messages
            # sent, in real life this message would be forwarded to the platform
            if(receiversOfMessage.Exists(targetPlatform))
               continue;
         
            # Verify that the comm message handler script defined by the platform exists
            string handlerScriptName = targetPlatform->GetMessageHandlerScriptName();
            if(!WsfSimulation.ScriptExists(handlerScriptName)) {
               # TODO log error
               retVal = false;
               continue; 
            }         

            # Generate a delay based on the registered comm links configuration
            double delay = commNetwork.GenerateDelay();
            double executionTime = timeNow + delay;

            # Create and dispatch the commMessage
            CommMessage commMessage =
               ConstructCommMessageCopy(aCommMessage, executionTime, repeatingPlatform, targetPlatform);
            
            string repeatType = "BROADCAST";
            if (commMessage.GetHopCount() > 1)
               repeatType = "REPEAT";

            # Check if commMessage is over Link16 and if target platform is jammed
            # if so, do not call ExecuteAtTime and log failure reason as "jammed"
            bool sourceIsJammed = JammerManagerInstance().IsLocationJammed(repeatingPlatform.Location(), commNetwork.GetName());
            bool targetIsJammed = JammerManagerInstance().IsLocationJammed(targetPlatform.Location(), commNetwork.GetName());
            if( sourceIsJammed || targetIsJammed ) { 
               if ( sourceIsJammed && targetIsJammed ){
                  LogCommMessage( timeNow, executionTime, commMessage, commNetwork, repeatType, "Both Jammed");   
               } else if ( sourceIsJammed ) {
                  LogCommMessage( timeNow, executionTime, commMessage, commNetwork, repeatType, "Transmitter Jammed");
               } else {
                  LogCommMessage( timeNow, executionTime, commMessage, commNetwork, repeatType, "Receiver Jammed");
               }
            } else {
               WsfSimulation.ExecuteAtTime( executionTime, "RepeatCommManagerBroadcastMessage", {commMessage});
               WsfSimulation.ExecuteAtTime( executionTime, handlerScriptName, {commMessage});
               
               # Log the message to the csv
               LogCommMessage( timeNow, executionTime, commMessage, commNetwork, repeatType, "");
            }                     
         }
      }
      return retVal; 
   }
   end_script
   
   # Attempts to send the given message on all CommLinks from the source platform
   # for the given message type. The delivery will be delayed based on the
   # configuration of the CommNetwork for the CommLink
   #
   # param aTimeNow        The current simulation time
   # param aSourcePlatform The platform where the message originated
   # param aMessage        The message to be sent
   # param aBroadcast      If true, receiving platforms will attempt to forward the message on all links. 
   # return                False if the message failed to be sent for whatever reason
   script CommMessage SendMessage( double aTimeNow,
                            WsfPlatform aSourcePlatform, 
                            WsfMessage aMessage,
                            bool aBroadcast)
      # This should never happen, but just in case...
      if(!mIsInitialized)
         Initialize();

      # Special handling for broadcast messages
      CommMessage baseMessage =
         ConstructCommMessage(aTimeNow, aSourcePlatform, aMessage, aBroadcast);
      
      if( aBroadcast ) {
         RepeatBroadcastMessage(baseMessage);
      } else {
         SendMessageOnAllLinks(baseMessage);
      }
      
      return baseMessage;

   end_script
end_script_struct

# Global method that creates/gets a static instance of
# the struct to attempt to treat it as a singleton.
script CommManager CommManagerInstance()
   static CommManager comm_manager =  CommManager();
   return comm_manager;
end_script

script void RepeatCommManagerBroadcastMessage( CommMessage commMessage) {
   # Resend the message too all neighbors
   CommManagerInstance().RepeatBroadcastMessage( commMessage );
}
end_script

# Global method that is invoked by the CommManagerObserver
# in response to the SIMULATION_STARTING event
script void InitializeCommManager() {
   CommManagerInstance().Initialize();
}
end_script

