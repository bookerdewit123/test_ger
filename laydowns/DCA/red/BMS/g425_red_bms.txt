# File generated by Wizard 2.2205.6 on Jan 8, 2026.

# Enumeration of behavior strings
script_struct RED_BMS_BEHAVIOR_ENUM
   script_variables
      string CLOSING    = "Closing";
      string RETREATING = "Retreating";
   end_script_variables
end_script_struct

# Getter for static instance of RED_BMS_BEHAVIOR_ENUM used to prevent
# excessive instantiation of the RED_BMS_BEHAVIOR_ENUM script_struct
script
   RED_BMS_BEHAVIOR_ENUM RED_BMS_BEHAVIOR_ENUM_INST() {
      static RED_BMS_BEHAVIOR_ENUM behaviorEnum = RED_BMS_BEHAVIOR_ENUM();
      return  behaviorEnum;
   }
end_script

script_variables
   # Constants defining the names of auxiliary data that will stored on
   # platforms to suport the BMS logic
   string cG425_RED_BMS_AUX_DATA_NAME_BEHAVIOR = "xBehavior_s";
end_script_variables

# The G425RedBms is a "singleton-like" manager for the battle
# management model for use in the G425 effort. Use the global
# G425BlueBmsInstance() method to access the single instance
# of the BMS.
script_struct G425RedBms

   script_variables
      string cWEAPON_NAME = "AA_13_R_37M_LRAAM_Launcher";
      
      # Storage for the weapon engagements for each red shooter
      Map<WsfPlatform, Set<WsfWeaponEngagement>> mEngagements =
         Map<WsfPlatform, Set<WsfWeaponEngagement>>();
   end_script_variables
   
   # Handles an incoming CommMessage and updates the battle
   # management state accordingly
   #
   # param aTrackMessage        The incoming track message
   # param aProcessingPlatform  The platform that is processing the message
   script void ProcessTrackMessage(WsfTrackMessage aTrackMessage, WsfPlatform aProcessingPlatform) {
   
      # Update platform state based on heading
      if (aProcessingPlatform.Heading() < 0 ) {
         aProcessingPlatform.SetAuxData(cG425_RED_BMS_AUX_DATA_NAME_BEHAVIOR, RED_BMS_BEHAVIOR_ENUM_INST().CLOSING);
      } else {
         aProcessingPlatform.SetAuxData(cG425_RED_BMS_AUX_DATA_NAME_BEHAVIOR, RED_BMS_BEHAVIOR_ENUM_INST().RETREATING);
         return;
      }
      
      # Only Su-35 will fire on blue tracks
      if ( aProcessingPlatform.Type() != "Su-35" )
         return;
      
      # The Su-35 will only act on tracks from its own sensor  (This is to favor targets
      # directly in front of the Su-35 as though should be the first tracks detected
      WsfPlatform originator = WsfSimulation.FindPlatform(aTrackMessage.Originator());
      if (originator != aProcessingPlatform)
         return;
         
      # Are we approaching the target?
      if( !aProcessingPlatform.CheckAuxData(cG425_RED_BMS_AUX_DATA_NAME_BEHAVIOR) ||
          aProcessingPlatform.AuxDataString(cG425_RED_BMS_AUX_DATA_NAME_BEHAVIOR) != RED_BMS_BEHAVIOR_ENUM_INST().CLOSING )
         return; 
      
      # Is the type of the target a valid BMS target???
      WsfTrack track = aTrackMessage.Track();
      WsfPlatform target = track.Target();
      if(target.IsNull() || !target.IsA_TypeOf("BLUE_FIGHTER"))
         return;
      
      # Set the scenario hot one time
      static bool scenarioHot = G425BlueBmsInstance().SetScenarioState(true);
      
      # Retrieve the weapon
      WsfWeapon weapon = aProcessingPlatform.Weapon(cWEAPON_NAME);
      assert(weapon.IsValid(), "ERROR: Unable to find the weapon " + cWEAPON_NAME + " on the platform " + aProcessingPlatform.Name()); 

      # Does this platform have remaining weapons
      if (weapon.QuantityRemaining() == 0)
         return;
         
      # Does this platform already have a missile flying at this target?
      if( mEngagements.Exists(aProcessingPlatform) ) {
         Set<WsfWeaponEngagement> engagements = mEngagements.Get(aProcessingPlatform);
         foreach(WsfWeaponEngagement engagement in engagements) {
            if(engagement.IsValid() && engagement.TargetPlatform() == target)
               return;
         }
      }
      
      # Fire on target
      weapon.Fire(track);
   }
   end_script
end_script_struct


# Global method that creates a static instance of the
# struct to attempt to treat it as a singleton.
script G425RedBms G425RedBmsInstance()
   static G425RedBms bms =  G425RedBms();
   return bms;
end_script

# Cleans up the tracked engagements when a red weapon reaches EOL
script void handleRedWeaponEndOfLife(WsfWeaponEngagement aWeaponEngagement, WsfPlatform aTargetPlatform){
   Map<WsfPlatform, Set<WsfWeaponEngagement>> allEngagements = G425RedBmsInstance().mEngagements;
   if(!allEngagements.Exists(aWeaponEngagement.FiringPlatform()))
      return;
   
   Set<WsfWeaponEngagement> engagements = allEngagements.Get(aWeaponEngagement.FiringPlatform());
   engagements.Erase(aWeaponEngagement);
}   
end_script 

# Tracks an engagement for a red weapon
script void handleRedWeaponFired(WsfWeaponEngagement aWeaponEngagement, WsfTrack aTargetTrack){
   Map<WsfPlatform, Set<WsfWeaponEngagement>> allEngagements = G425RedBmsInstance().mEngagements;
   if(!allEngagements.Exists(aWeaponEngagement.FiringPlatform()))
      allEngagements.Set(aWeaponEngagement.FiringPlatform(), Set<WsfWeaponEngagement>());
   
   Set<WsfWeaponEngagement> engagements = allEngagements.Get(aWeaponEngagement.FiringPlatform());
   engagements.Insert(aWeaponEngagement);
}
end_script

observer
   enable WEAPON_HIT handleRedWeaponEndOfLife
   enable WEAPON_MISSED handleRedWeaponEndOfLife
   enable WEAPON_FIRED handleRedWeaponFired
end_observer