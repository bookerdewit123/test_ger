# File generated by Wizard 2.2205.6 on Nov 25, 2025.

include_once ../CommHandlers/comm_network_names.txt

# The G425BlueBms is a "singleton-like" manager for the battle
# management model for use in the G425 effort. Use the global
# G425BlueBmsInstance() method to access the single instance
# of the BMS.
script_struct G425BlueBms

   script Array<WsfPlatform> GetShootersSide(string side)
      Array<WsfPlatform> blueShooters = Array<WsfPlatform>();
      
      for (int ii = 0; ii < WsfSimulation.PlatformCount(); ii += 1)
      {
         # Get platform
         WsfPlatform iPlatform = WsfSimulation.PlatformEntry(ii);
         if (iPlatform.IsNull()) continue;
         
         # Identify shooters only
         if (iPlatform.WeaponCount() == 0) continue;
         
         # Must be correct side
         if (iPlatform.Side() != side) continue;
         
         # Add to list
         blueShooters.PushBack(iPlatform);
      }
      
      return blueShooters;
   end_script
   
   script WsfTrack GetLocalTrack(WsfPlatform aTarget, WsfPlatform aPlatform)
   
      WsfTrack mLocalTrack;
      foreach (WsfTrack iTrack in aPlatform.MasterTrackList())
      {
         if(aTarget.IsValid()){
            if (iTrack.TargetName() == aTarget.Name())
            {
               mLocalTrack = iTrack;
               break;
            }
          }
      }
      return mLocalTrack;
   end_script
   
   script WsfTrack canShooterEngage(WsfPlatform aShooter, string aWeaponName, WsfPlatform aTarget)
      WsfTrack organicTrack;
      
      # Don't shoot while turning
      double delta = aShooter.Heading() - mapFighterHeading[aShooter.Name()];
      delta = MATH.Fmod(delta, 180);
      delta = MATH.Fabs(MATH.Fabs(delta)-90);
      bool isTurning = delta < 10;

      #MIKE: Figure out what Weapon Quantity actually means
      # weapons check
      if (aShooter.Weapon(aWeaponName).QuantityRemaining() == 0) return organicTrack;
      
      # organic sensor check
      
      foreach (WsfTrack iTrack in aShooter.MasterTrackList())
      {  
         if (iTrack.TargetName() == aTarget.Name())
         {
            organicTrack = iTrack;
            break;
         }
      }
      
      return organicTrack;
            
   end_script
   
   # Releases a shooter and it's target from an existing engagement
   # allowing the shooter to potentially engage other targets and
   # the target to be engaged by other shooters.
   #
   # param aShooter The platform that was the aggressor in the engagement
   # param aTarget  The platform that was the defender in the engagement
   script void Disengage(WsfPlatform aShooter, WsfPlatform aTarget) {
      aShooter.DeleteAuxData("xPersecutionTarget_O");
      aTarget.DeleteAuxData("xPersecutedBy_O");
   }
   end_script

   # Handles an incoming CommMessage and updates the battle
   # management state accordingly
   #
   #param aCommMessage The incoming comm message
   script void HandleCommMessage(CommMessage aCommMessage)
      if(aCommMessage.GetSourcePlatform() == aCommMessage.GetTargetPlatform()) {
         # Ignore self sent messages
         # This is a hack to prevent the AEW from trying to fire on a target it has detected.
         # The BMS needs to handle this case and then have this hack removed
         return;
      }

      # Handle incoming messages
      WsfMessage message = aCommMessage.GetMessage();
      if( message.Type()=="WSF_TRACK_MESSAGE") {
         # Handle Track Message 
         WsfTrackMessage trackMsg = WsfTrackMessage((WsfTrackMessage)message);  # create a working copy
         WsfTrack mTrack = trackMsg.Track();
         WsfPlatform mTarget = mTrack.Target();
         WsfPlatform mC2 = aCommMessage.GetTargetPlatform();
         
         # Handle Fire failures - disengage the target so that another platform can be assigned to take the shot 
         if( message.SubType() == "FAILED_TO_FIRE" ) {
            Disengage(aCommMessage.GetSourcePlatform(), mTarget);
            #string console_msg = ">>>C2 " + (string)aCommMessage.GetTimestamp() + " : Disengaging target: " + trackMsg.Track().TargetName() + " [" + trackMsg.Track().TrackId().ToString() + "]";
            #writeln(console_msg);
            return;       
         }
         
         #---------------------------
         # fire permission check
         #---------------------------
         # Only shoot when processed
         # MIKE: The following line is useful for the MULTIAXIS
         
         # Verify there is a target
         if (mTarget.IsNull() || !mTarget.IsValid())
            return; 
         
         # Don't fire on blue targets
         if (mTarget.Side() == "blue")
            return;
         
         # Don't task against a target that has already been tasked
         if(mTarget.AuxDataExists("xPersecutedBy_O"))
            return;

         # The message source is now a potential shooter
         WsfPlatform shooter = aCommMessage.GetSourcePlatform();
         
         # Don't task if this shooter is already tasked
         if(shooter.AuxDataExists("xPersecutionTarget_O"))
            return;

         # HACK - let C2 track weapon inventories automagically. Need to determine if the
         # C2 will have this at the beginning or need to build it. For now if the platform
         # has no missiles, then don't task it.
         if(shooter.Weapon("aam").QuantityRemaining() == 0)
            return;

         trackMsg.SetSubType("SHOOT");
         Map<CommNetwork, double> delays = CommManagerInstance().SendMessageToTarget( aCommMessage.GetTimestamp(), 
                                                                                      aCommMessage.GetTargetPlatform(), 
                                                                                      aCommMessage.GetSourcePlatform(),
                                                                                      trackMsg );

         if(delays.Size() > 0) {
         
            # Comment on assignment
            shooter.Comment("Receiving Shoot Tasking");

            # Draw the message(s)
            double longestDelay = 0.0;
            WsfDraw draw = WsfDraw();
            draw.SetLineSize(3);
            foreach (CommNetwork commNetwork : double delay in delays) {
               if (delay > longestDelay)
                  longestDelay = delay;
               
               # Draw assignment message from C2 platform to shooter platform
               if( commNetwork.GetName() == gcLINK16_NETWORK_NAME ) {
                  draw.SetColor(1.0, 0.702, 0.263);  # Yellow-Orange
                  draw.SetLineStyle("long_dashed");
               } else if ( commNetwork.GetName() == gcMADL_NETWORK_NAME ) {
                  draw.SetColor(1.0, 0.702, 0.263);  # Yellow-Orange
                  draw.SetLineStyle("dotted");
               } else {
                  # This case should never happen
                  draw.SetColor(1.0, 1.0, 1.0);  # White
               }
               draw.SetDuration(delay);
               draw.BeginLines();
                  draw.Vertex(mC2);
                  draw.Vertex(shooter);
               draw.End();
            }
            
            # Draw shooter to target assignment by line
            draw.SetColor(1,0,0);  # Red
            draw.SetLineStyle("solid");
            draw.SetDuration(longestDelay);
            draw.BeginLines();
               draw.Vertex(mTarget);
               draw.Vertex(shooter);
            draw.End();
                                                    
            # Set aux data on the shooter and 
            # target to track the engagement
            shooter.SetAuxData("xPersecutionTarget_O", mTarget);
            mTarget.SetAuxData("xPersecutedBy_O", shooter);
         }
      }
   end_script
end_script_struct


# Global method that creates a static instance of the
# struct to attempt to treat it as a singleton.
script G425BlueBms G425BlueBmsInstance()
   static G425BlueBms bms =  G425BlueBms();
   return bms;
end_script

script void handleWeaponEndOfLife(WsfWeaponEngagement aWeaponEngagement, WsfPlatform aTargetPlatform)
   # Get the shooter (the aircraft that fired, not the weapon)
   WsfPlatform shooter = aWeaponEngagement.FiringPlatform();
   
   # Only disengage if the shooter is still valid
   if (shooter.IsValid() && aTargetPlatform.IsValid())
   {
      G425BlueBmsInstance().Disengage(shooter, aTargetPlatform);
   }
   
   # Handle weapon platform cleanup separately
   WsfPlatform weaponPlat = aWeaponEngagement.WeaponPlatform();
   if (weaponPlat.IsValid() && weaponPlat.AuxDataExists("GlobalTrackNumber"))
   {
      weaponPlat.DeleteAuxData("GlobalTrackNumber");
   }
end_script
observer
   enable WEAPON_HIT handleWeaponEndOfLife
   enable WEAPON_MISSED handleWeaponEndOfLife
end_observer