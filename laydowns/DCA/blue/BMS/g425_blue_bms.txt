# File generated by Wizard 2.2205.6 on Nov 25, 2025.

include_once ../CommHandlers/comm_network_names.txt
include_once weapons/blue/g425/g425_weapon_effect.txt

# Enumeration of behavior strings
script_struct BEHAVIOR_ENUM
   script_variables
      string CAP_FORWARD  = "Cap Forward";
      string CAP_BACKWARD = "Cap Backward";
      string RTB          = "RTB";
   end_script_variables
end_script_struct

# Getter for static instance of BEHAVIOR_ENUM used to prevent
# excessive instantiation of the BEHAVIOR_ENUM script_struct
script
   BEHAVIOR_ENUM BEHAVIOR_ENUM_INST() {
      static BEHAVIOR_ENUM behaviorEnum = BEHAVIOR_ENUM();
      return  behaviorEnum;
   }
end_script

# Enumeration of claim type strings
script_struct CLAIM_ENUM
   script_variables
      string NONE      = "None";                   # No claim
      string INTERCEPT = "Intercept";              # a claim against a target that cannot immediately be engaged 
      string FIRE      = "Fire";                   # result from CheckClaim that indicates the platform should fire on the target
      string ENGAGE    = "Engage";                 # a claim asserted when a platform fires on a target and does not already have a primary claim
      string AOO       = "Attack of Opportunity";  # a claim asserted when a platform fires on a target. but it already have a primary claim on another target
   end_script_variables
end_script_struct

# Getter for static instance of CLAIM_ENUM used to prevent
# excessive instantiation of the CLAIM_ENUM script_struct
script
   CLAIM_ENUM CLAIM_ENUM_INST() {
      static CLAIM_ENUM claimEnum = CLAIM_ENUM();
      return  claimEnum;
   }
end_script

script_variables
   # Constants defining the names of auxiliary data that will stored on
   # platforms to suport the BMS logic
   string cG425_BMS_AUX_DATA_NAME_BEHAVIOR = "xBehavior_s";
   string cG425_BMS_AUX_DATA_NAME_PCT      = "xPrimaryClaimTarget_o";
   string cG425_BMS_AUX_DATA_NAME_PCV      = "xPrimaryClaimValue_s";
   
   # Constants defining the type for a Claim Message and the names of
   # auxiliary data that will stored on the message
   string cG425_BMS_AUX_DATA_NAME_MSG_TYPE       = "G425_BMS_CLAIM_MESSAGE";
   string cG425_BMS_AUX_DATA_NAME_MSG_CLAIMANT   = "xClaimant_o";
   string cG425_BMS_AUX_DATA_NAME_MSG_TRACK      = "xClaimedTrack_o";
end_script_variables


# The G425BlueBms is a "singleton-like" manager for the battle
# management model for use in the G425 effort. Use the global
# G425BlueBmsInstance() method to access the single instance
# of the BMS.
script_struct G425BlueBms

   script_variables
      # Tracks when the BMS should be active
      # TODO: This should default false and be set to true by Red
      # BMS on first detection of blue forces (jamming starts as well)
      bool mScenarioIsHot = true; # false;
      
      # Tracks the Situation Awareness of each individual blue platform
      # PlatformSA -> Target -> Claimer -> Claim Type
      # The Target is a WsfPlatform for Strike and a WsfWeapon for Multiaxis so we abstract to Object here
      Map<WsfPlatform, Map<WsfPlatform, Map<WsfPlatform, string>>> mSAByPlatform =
         Map<WsfPlatform, Map<WsfPlatform, Map<WsfPlatform, string>>>();

      # Tracks the TRUE Situation for all platforms
      # Target -> Claimer -> Claim Type
      # The Target is a WsfPlatform for Strike and a WsfWeapon for Multiaxis
      Map<WsfPlatform, Map<WsfPlatform, string>>  mSATruth =
          Map<WsfPlatform, Map<WsfPlatform, string>>();

      string cWEAPON_NAME = "AIM120_MRAAM_Launcher";
      
      string cBMS_LOG_FILE_NAME = "BlueBattleManager";
   end_script_variables
   
   # Setter/Getter for Scenario State
   script bool ScenarioIsHot() { return mScenarioIsHot; } end_script
   script void SetScenarioState(bool aIsHot) { mScenarioIsHot = aIsHot; } end_script
   

   script Map<WsfPlatform, string> GetSATruthForTarget(WsfPlatform aTarget) {
      Map<WsfPlatform, string> SATruth = Map<WsfPlatform, string>();
      if(mSATruth.Exists(aTarget))
         SATruth = mSATruth.Get(aTarget);
      
      return SATruth;
   }
   end_script

   # Appends a new line to the csv output file describing a message that was
   # sent on a comm network.
   #
   # param aSendTime    The simulation time when the message was created
   # param aReceiveTime The simulation at which time the message will be handled by the target platform
   # param aCommMessage The CommMessage sent
   # param aCommNetwork The CommNetwork the message on which the message was sent 
   script void LogBMSEvent( WsfPlatform aBluePlatform,
                            WsfPlatform aTargetPlatform,
                            WsfTrack    aTargetTrack,
                            string      aClaim,
                            string      aDecision,
                            string      aPk ) {

      # Get the weapon Quantity
      WsfWeapon weapon = aBluePlatform.Weapon(cWEAPON_NAME);
      assert(weapon.IsValid(), "ERROR: Unable to find the weapon " + cWEAPON_NAME + " on the platform " + aBluePlatform.Name()); 


      # Get the Auxiliary Data                             
      string currentBehavior = "???";
      if(aBluePlatform.CheckAuxData(cG425_BMS_AUX_DATA_NAME_BEHAVIOR))
         currentBehavior = aBluePlatform.AuxDataString(cG425_BMS_AUX_DATA_NAME_BEHAVIOR);
      
      string targetName = "None";
      if(aBluePlatform.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCT))
         targetName = ((WsfPlatform)aBluePlatform.AuxDataObject(cG425_BMS_AUX_DATA_NAME_PCT)).Name();
      
      string targetClaim = "None";
      if(aBluePlatform.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCV))
         targetClaim = aBluePlatform.AuxDataString(cG425_BMS_AUX_DATA_NAME_PCV);
      
      # Get the Truth SA
      string truthClaims = "";
      Map<WsfPlatform, string> SATruth = GetSATruthForTarget(aTargetPlatform);
      foreach ( WsfPlatform claimant : string claimType in SATruth) {
         if( claimType != CLAIM_ENUM_INST().NONE )
            truthClaims = truthClaims +  claimant.Name() + "[" + claimType + "];"; 
      } 

      string trackId = "N/A";
      string trackAge = "N/A";
      if(aTargetTrack.IsValid()) {
         trackId = aTargetTrack.TrackId().ToString();
         trackAge=(string)aTargetTrack.TimeSinceUpdated();
      }
                       
      # Build the log entry and write it      
      Array<string> fields = {
         (string)TIME_NOW,
         aBluePlatform.Name(),
         currentBehavior,
         (string)weapon.QuantityRemaining(),
         trackId,
         trackAge,
         aTargetPlatform.Name(),
         aClaim,
         aDecision,
         aPk,
         targetName,
         targetClaim,
         truthClaims
      };
      CSVLogFileManagerInstance().LogToFile(cBMS_LOG_FILE_NAME, fields);
   }
   end_script


   # Could this shooting platform immediately release the given weapon against the given target
   #
   # param aShooter    The platform being checked
   # param aWeaponName The weapon to consider for the check 
   # param aTrack      The track to consider for the check
   script bool canShooterEngage(WsfPlatform aShooter, string aWeaponName, WsfTrack aTrack)
      
      # TODO Check firing arc      

      # TODO Check Track Quality
      
      # Check payload
      if (aShooter.Weapon(aWeaponName).QuantityRemaining() == 0)
         return false;
      
      # Check Range/Min PK
      double rangeNm = aShooter.SlantRangeTo(aTrack)*Math.NM_PER_M();
      double calculatedPk = CalculateAim120Pk(rangeNm);
      static double blue_min_pk = $<BLUE_MINIMUM_PK:0.8>$; # Grab the defined value once 
      if(calculatedPk < blue_min_pk)
         return false;
      
      return true;
   end_script
   
   script bool IsActiveCombatant(WsfPlatform aPlatform) {
      # Is this platform a blue fighter?
      if(!aPlatform.IsA_TypeOf("BLUE_FIGHTER"))
         return false;

      # Does this platform type engage targets?
      return  ( aPlatform.Type() == "4thGenFighter"
                # uncomment this line when the JammerManager is implemented in issue  4667
                # || processingPlatform.Type() == "5thGenFighter" and JammermanagerInstance().IsLocationJammed(processingPlatform.Location())
               );
   } 
   end_script
   
   # Convenience function for safely retrieving a platforms SA
   #
   # param aPlatform The platform whose SA is being queried
   script Map<WsfPlatform,Map<WsfPlatform, string>> GetOrCreateSAForPlatform(WsfPlatform aPlatform) {
      # Do we have storage for this platforms SA? If not create it
      if(!mSAByPlatform.Exists(aPlatform))
        mSAByPlatform.Set(aPlatform, Map<WsfPlatform,Map<WsfPlatform, string>>());
      
      return mSAByPlatform.Get(aPlatform);  
   }
   end_script
   
   # Convenience Function for safely retrieving a platforms perceived SA versus a sepcific target
   #
   # param aPlatform The platform whose SA is being queried
   # param aTarget   The specific target for which to retrieve SA  
   script Map<WsfPlatform, string> GetOrCreateTargetSAForPlatform(WsfPlatform aPlatform, WsfPlatform aTarget) {
      Map<WsfPlatform,Map<WsfPlatform, string>> platformSA = GetOrCreateSAForPlatform(aPlatform);
      
      # Does this platform have SA on this target? If not, add an entry to track SA on it.
      if(!platformSA.Exists(aTarget))
          platformSA.Set(aTarget, Map<WsfPlatform, string>());
      
      return  platformSA.Get(aTarget);
   }
   end_script

   # Creates/Updates the Situational Awareness from the point of
   # view of a single platform
   #
   # param aSAPlatform       The platform whose SA is being updated 
   # param aTarget           The target that the platform is claiming
   # param aClaimingPlatform The platform asserting the claim
   # param aClaimType        The type of claim that was asserted
   script void UpdatePlatformSA(WsfPlatform aSAPlatform, WsfPlatform aTarget, WsfPlatform aClaimingPlatform, string aClaimType) {
      GetOrCreateTargetSAForPlatform(aSAPlatform, aTarget).Set(aClaimingPlatform, aClaimType); 
   }
   end_script
   
   # Creates/Updates the Truth Situational Awareness data structure
   #
   # param aClaimingPlatform The platform asserting the claim
   # param aTarget           The target that the platform is claiming
   # param aClaimType        The type of claim that was asserted
   script void UpdateTruthSA( WsfPlatform aClaimingPlatform, WsfPlatform aTarget, string aClaimType) {
      
      if(!mSATruth.Exists(aTarget))
         mSATruth.Set(aTarget, Map<WsfPlatform, string>());
      
      Map<WsfPlatform, string> claimants = mSATruth.Get(aTarget);
      
      
      claimants.Set(aClaimingPlatform, aClaimType);
   }
   end_script
   
   script void HandlePlatformDestroyed(WsfPlatform destroyedPlatform) {
      if(destroyedPlatform.Side() == "red") {
         # remove references to this target from all platforms SA
         foreach( WsfPlatform platformSA : Map<WsfPlatform, Map<WsfPlatform, string>> sa in mSAByPlatform ) {
            if(sa.Exists(destroyedPlatform))
               sa.Erase(destroyedPlatform);
         }
           
         # remove all references to this target from Truth
         if(mSATruth.Exists(destroyedPlatform))
            mSATruth.Erase(destroyedPlatform);
      } else if (destroyedPlatform.Side() == "blue") {
         # TODO: does this platform have weapons in the air?
         
      }
   }
   end_script
   
   script void DebugDumpAuxDataForPlatform(WsfPlatform aPlatform) {
      writeln_debug("");
      writeln_debug("AUX DATA FOR " + aPlatform.Name());
      # Retrieve auxiliary data from the claimant platform
      # which is required for this logic.
      if(aPlatform.CheckAuxData(cG425_BMS_AUX_DATA_NAME_BEHAVIOR))
         writeln_debug("    BEHAVIOR: " + aPlatform.AuxDataString(cG425_BMS_AUX_DATA_NAME_BEHAVIOR));
      else
         writeln_debug("    BEHAVIOR: NOT FOUND");

      if(aPlatform.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCT)) {
         WsfPlatform PCT = (WsfPlatform)aPlatform.AuxDataObject(cG425_BMS_AUX_DATA_NAME_PCT);
         writeln_debug("    PCT: " + PCT.Name());
      } else {
         writeln_debug("    PCT: NOT FOUND");
      }

      if(aPlatform.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCV))
         writeln_debug("    PCV: " + aPlatform.AuxDataString(cG425_BMS_AUX_DATA_NAME_PCV));
      else
         writeln_debug("    PCV: NOT FOUND");
   }
   end_script
   
   script void DebugDumpSAForPlatform(WsfPlatform platform) {
      writeln_debug("");
      writeln_debug("LOCAL SA for platform " + platform.Name());
      if(!mSAByPlatform.Exists(platform)) {
         writeln_debug("    NONE");
      } else {
         Map<WsfPlatform, Map<WsfPlatform, string>> platformSA = mSAByPlatform.Get(platform);
         foreach(WsfPlatform target : Map<WsfPlatform, string> claimantData in platformSA) {
            writeln_debug("    " + target.Name());
            foreach( WsfPlatform claimant : string claimType in claimantData) {
               if(claimant.IsValid())
                  writeln_debug("      " + claimant.Name() + ": " + claimType);
               else 
                  writeln_debug("      ERROR: claimant is NULL with claim type: " + claimType);
            }
         }
      }
      writeln_debug("");
   }
   end_script

   script void DebugDumpSATruth() {
      foreach(WsfPlatform target_obj : Map<WsfPlatform, string> sa in mSATruth) {
         WsfPlatform target = (WsfPlatform)target_obj;
         if(target.IsNull()) {
             writeln_debug("TRUTH SA: NULL TARGET FOUND!!!");
         } else {
            writeln_debug("TRUTH SA: " + target.Name() );
            foreach( WsfPlatform claimant : string claimType in sa )
               writeln_debug("    " + claimant.Name() + " - " + claimType );
         }
      }
   }
   end_script
   
   script WsfPlatform GetClosestPotentialClaimantPerLocalSA(WsfTrack track, Map<WsfPlatform,Map<WsfPlatform, string>> localSA){
      writeln_debug("Building Claimant List...");
      Map<double, WsfPlatform> potential_claimants = Map<double, WsfPlatform>();
      WsfGeoPoint trackReportedPosition = track.ReportedLocation();
      WsfPlatform target = track.Target();

      if(target.IsValid()) {
         for (int i = 0; i < WsfSimulation.PlatformCount(); i = i + 1)
         {
            WsfPlatform potentialClaimant = WsfSimulation.PlatformEntry(i);

            # skip any inactive combatants
            if(!IsActiveCombatant(potentialClaimant))
               continue;

            # Retrieve auxiliary data from the potential claimant
            # platform which is required for this logic.
            assert(potentialClaimant.CheckAuxData(cG425_BMS_AUX_DATA_NAME_BEHAVIOR), "ERROR: Blue BMS executed against a platform which does not have required auxiliary data: " + cG425_BMS_AUX_DATA_NAME_BEHAVIOR);
            string pcBehavior =  potentialClaimant.AuxDataString(cG425_BMS_AUX_DATA_NAME_BEHAVIOR);

            assert(potentialClaimant.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCT), "ERROR: Blue BMS executed against a platform which does not have required auxiliary data: " + cG425_BMS_AUX_DATA_NAME_PCT);
            Object pcPCT =  potentialClaimant.AuxDataObject(cG425_BMS_AUX_DATA_NAME_PCT);

            assert(potentialClaimant.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCV), "ERROR: Blue BMS executed against a platform which does not have required auxiliary data: " + cG425_BMS_AUX_DATA_NAME_PCV);
            string pcPCV =  potentialClaimant.AuxDataString(cG425_BMS_AUX_DATA_NAME_PCV);

            
            if(pcBehavior != BEHAVIOR_ENUM_INST().CAP_FORWARD) {
               writeln_debug(potentialClaimant.Name() + "[" + potentialClaimant.Type() + "]" + " is not Capping Forward");
               continue;
            }
            
            # iterate over the current claimants SA and see if the platform, p,
            # has any current primary claims in that SA
            bool isPotentialClaimant = true;
            foreach (WsfPlatform sa_target_object : Map<WsfPlatform, string> claim in localSA)
            {
               WsfPlatform sa_target = (WsfPlatform)sa_target_object;
               
               if( sa_target != target && 
                   claim.Exists(potentialClaimant) && 
                   claim.Get(potentialClaimant) != CLAIM_ENUM_INST().NONE) {
                  # This potential claimant already has a primary claim against another target so don't consider him
                  writeln_debug(potentialClaimant.Name() + "[" + potentialClaimant.Type() + "]" + " already has a primary [" + claim.Get(potentialClaimant) +"] against another target: " + sa_target.Name());
                  isPotentialClaimant = false;
                  break;
               }
            }
            
            if(isPotentialClaimant) {
               # Get the slant range between the platform and the tartget and
               # add to potential claimants
               WsfGeoPoint platformPosition = potentialClaimant.Location();
               double distance = platformPosition.SlantRangeTo(trackReportedPosition);
               potential_claimants.Set(distance, potentialClaimant);
               writeln_debug(potentialClaimant.Name() + "[" + potentialClaimant.Type() + "]" + " is a potential claimant at distance " + (string)distance);
            }
         }
      }
      writeln_debug("... Claimant List has " + (string)potential_claimants.Size() + " entries");
      
      if( potential_claimants.Size() > 0 ) {
         WsfPlatform closest = (WsfPlatform)potential_claimants.Get(potential_claimants.ElementKeyAtIndex(0));
         writeln_debug("Closest claimant is " + closest.Name() + "[" + closest.Type() + "]");
         return closest;
      }
      return null;
   }
   end_script

   # Determines the type of shooting claim that the given claimant platform would have
   # against the given track using that platforms SA and current conditions 
   #
   # param aClaimant     The platform whose claim is being checked
   # param aTrackMessage The track against which the claim is being checked
   # param aWeaponType   The weaopn type that will be used for the claim
   script string CheckClaim(WsfPlatform aClaimant, WsfTrackMessage aTrackMessage, string aWeaponType) {
      WsfTrack track = aTrackMessage.Track();
      WsfPlatform target = track.Target();
      
      # Validate there is a target for the track
      if(target.IsNull()) {
         writeln_warning("WARNING: Unable to check claim for " + aClaimant.Name() + " against " + track.TargetName() + " - target is null");
         return CLAIM_ENUM_INST().NONE;
      }

      # Get this claimants SA
      Map<WsfPlatform,Map<WsfPlatform, string>> claimantsSA = GetOrCreateSAForPlatform(aClaimant);  
      
      # Get current SA for this claimant against this target
      Map<WsfPlatform, string> SAOnTarget = GetOrCreateTargetSAForPlatform(aClaimant, target);

      DebugDumpSAForPlatform(aClaimant);
      
      # Iterate over known claims against this target
      # If any claimant has a claim, this platform cannot claim
      bool otherPlatformHasClaim = false;
      foreach(WsfPlatform otherClaimant : string claimType in SAOnTarget) {
         if(claimType != CLAIM_ENUM_INST().NONE && claimType != CLAIM_ENUM_INST().INTERCEPT) {
            writeln_debug((string)TIME_NOW + " [" + aClaimant.Name() + "] Other platform " + otherClaimant.Name() + " already has an " + claimType + " claim against " + target.Name());
            // print the platform claim, local SA, and Truth
            DebugDumpAuxDataForPlatform(otherClaimant);
            DebugDumpSAForPlatform(otherClaimant);
            DebugDumpSATruth();
            
            otherPlatformHasClaim = true;
            break;
         }
      }
      if(otherPlatformHasClaim)
         return CLAIM_ENUM_INST().NONE;
      
      # Retrieve auxiliary data from the claimant platform
      # which is required for this logic.
      assert(aClaimant.CheckAuxData(cG425_BMS_AUX_DATA_NAME_BEHAVIOR), "ERROR: Blue BMS executed against a platform which does not have required auxiliary data: " + cG425_BMS_AUX_DATA_NAME_BEHAVIOR);
      string behavior =  aClaimant.AuxDataString(cG425_BMS_AUX_DATA_NAME_BEHAVIOR);

      assert(aClaimant.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCT), "ERROR: Blue BMS executed against a platform which does not have required auxiliary data: " + cG425_BMS_AUX_DATA_NAME_PCT);
      Object PCT =  aClaimant.AuxDataObject(cG425_BMS_AUX_DATA_NAME_PCT);

      assert(aClaimant.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCV), "ERROR: Blue BMS executed against a platform which does not have required auxiliary data: " + cG425_BMS_AUX_DATA_NAME_PCV);
      string PCV =  aClaimant.AuxDataString(cG425_BMS_AUX_DATA_NAME_PCV);
      
      # Should this claimant surrender their claim?
      if( behavior == BEHAVIOR_ENUM_INST().CAP_BACKWARD &&
          PCV == CLAIM_ENUM_INST().INTERCEPT ) {
         writeln_debug(aClaimant.Name() + " should release claim against " + target.Name()); 
         return CLAIM_ENUM_INST().NONE;
      }
      
      # Is this claimant facing the enemy?
      if( behavior == BEHAVIOR_ENUM_INST().CAP_FORWARD ) {
         # create a map of distances to target to blue fighters which are capping
         # forward and which this claimant believes do not have a claim on any target
         writeln_debug((string)TIME_NOW + " - Determining if " + aClaimant.Name() + "[" + aClaimant.Type() + "]" + " is the closest claimant to " + target.Name()); 
         
         WsfPlatform closest = GetClosestPotentialClaimantPerLocalSA(track, claimantsSA);
         
         # Of this list, is there no potential claimant or is this claimant the closest?
         if ( closest == null || closest == aClaimant)
         {
            # Is this claimant in a position to fire?
            if(canShooterEngage(aClaimant, aWeaponType, track)) {
               writeln_debug(aClaimant.Name() + " can engage " + target.Name());
               return CLAIM_ENUM_INST().FIRE;
            } else {
               writeln_debug(aClaimant.Name() + " can intercept " + target.Name());
               return CLAIM_ENUM_INST().INTERCEPT;
            }
         }         
      } else {
         writeln_developer("Claimant behavior state is " + behavior);
      }
        
      return CLAIM_ENUM_INST().NONE;
   }
   end_script

   # Convenience function for transmitting a claim that is being asserted
   # NOTE: This will become a broadcast as part of issue 4677  
   script void sendClaimMessage( WsfPlatform aClaimingPlatform, WsfTrack aTrack, string aClaimType ) {
   
      if(!aTrack.IsValid())
         bool crap = true;
   
      WsfMessage claimMessage = WsfMessage();
      claimMessage.SetType(cG425_BMS_AUX_DATA_NAME_MSG_TYPE);
      claimMessage.SetSubType(aClaimType);
      
      claimMessage.SetAuxData(cG425_BMS_AUX_DATA_NAME_MSG_CLAIMANT, aClaimingPlatform);
      claimMessage.SetAuxData(cG425_BMS_AUX_DATA_NAME_MSG_TRACK, WsfTrack(aTrack)); # send a copy because the original will be deleted
      
      CommManagerInstance().SendMessage(TIME_NOW, aClaimingPlatform, claimMessage);
   }
   end_script
   
   # Handles an incoming CommMessage and updates the battle
   # management state accordingly
   #
   # param aCommMessage The incoming comm message
   script void HandleCommMessage(CommMessage aCommMessage)
      # Get the platform that is processing this message
      WsfPlatform processingPlatform = aCommMessage.GetTargetPlatform();
      
      # Only execute the BMS against BLUE_FIGHTER platforms
      if(!processingPlatform.IsA_TypeOf("BLUE_FIGHTER"))
         return;

      # Handle incoming messages
      WsfMessage message = aCommMessage.GetMessage();
      if( message.Type()==cG425_BMS_AUX_DATA_NAME_MSG_TYPE ) {
         # This is a claim message from another platform. Fuse it into the local SA
         
         # Grab aux data from the message
         assert(message.CheckAuxData(cG425_BMS_AUX_DATA_NAME_MSG_CLAIMANT), "ERROR: Blue BMS received a Claim Message missing auxiliary data: " + cG425_BMS_AUX_DATA_NAME_MSG_CLAIMANT);
         assert(message.CheckAuxData(cG425_BMS_AUX_DATA_NAME_MSG_TRACK), "ERROR: Blue BMS received a Claim Message missing auxiliary data: " + cG425_BMS_AUX_DATA_NAME_MSG_TRACK);
         
         WsfPlatform claimant = (WsfPlatform) message.AuxDataObject(cG425_BMS_AUX_DATA_NAME_MSG_CLAIMANT);
         WsfTrack track = (WsfTrack) message.AuxDataObject(cG425_BMS_AUX_DATA_NAME_MSG_TRACK);
         assert(claimant.IsValid(), "ERROR: Blue BMS was unable to get a valid claimant from a Claim Message");
         assert(track.IsValid(), "ERROR: Blue BMS was unable to get a valid target track from a Claim Message");
         
         WsfPlatform target = track.Target();
         string claimType = message.SubType();
         
         # update BMS SA for this platform
         Map<WsfPlatform, string> SAOnTarget = GetOrCreateTargetSAForPlatform(processingPlatform, target);
         SAOnTarget.Set(claimant, claimType);
      } else if( message.Type()=="WSF_TRACK_MESSAGE") {
         # If the current platform is RTB, then do nothing
         if(processingPlatform.AuxDataString(cG425_BMS_AUX_DATA_NAME_BEHAVIOR) == BEHAVIOR_ENUM_INST().RTB)
            return;

         # Update Capping state based on heading
         # Note: this should not be updated here,
         # but rather by the behavior tree
         if (processingPlatform.Heading() > 0 ) 
            processingPlatform.SetAuxData(cG425_BMS_AUX_DATA_NAME_BEHAVIOR, BEHAVIOR_ENUM_INST().CAP_FORWARD);
         else
            processingPlatform.SetAuxData(cG425_BMS_AUX_DATA_NAME_BEHAVIOR, BEHAVIOR_ENUM_INST().CAP_BACKWARD);

         # Handle Track Message 
         WsfTrackMessage trackMsg = WsfTrackMessage((WsfTrackMessage)message);  # create a working copy

         # Do nothing unless the scenario is hot
         if(!ScenarioIsHot())
            return;

         # Is the type of the processing platform a potential combatant?
         if(!IsActiveCombatant(processingPlatform))
            return;

         # Is the type of the target a valid BMS target???
         WsfTrack track = trackMsg.Track();
         WsfPlatform target = track.Target();
         if(target.IsNull() || !target.IsA_TypeOf("RED_FIGHTER"))
            return;

         # What would be this claimants claim type based on current conditions
         string claim_check = CheckClaim(processingPlatform, trackMsg, cWEAPON_NAME);
         writeln_developer(processingPlatform.Name() + ": CheckClaim returned " + claim_check);  

         # Retrieve auxiliary and target/behavior data from the
         # claimant platform, which is required for this logic.
         assert(processingPlatform.CheckAuxData(cG425_BMS_AUX_DATA_NAME_BEHAVIOR), "ERROR: Blue BMS executed against a platform which does not have required auxiliary data: " + cG425_BMS_AUX_DATA_NAME_BEHAVIOR);
         string behavior =  processingPlatform.AuxDataString(cG425_BMS_AUX_DATA_NAME_BEHAVIOR);

         assert(processingPlatform.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCT), "ERROR: Blue BMS executed against a platform which does not have required auxiliary data: " + cG425_BMS_AUX_DATA_NAME_PCT);
         Object PCT =  processingPlatform.AuxDataObject(cG425_BMS_AUX_DATA_NAME_PCT);

         assert(processingPlatform.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCV), "ERROR: Blue BMS executed against a platform which does not have required auxiliary data: " + cG425_BMS_AUX_DATA_NAME_PCV);
         string PCV =  processingPlatform.AuxDataString(cG425_BMS_AUX_DATA_NAME_PCV);
         
         # Retrieve the weapon
         WsfWeapon weapon = processingPlatform.Weapon(cWEAPON_NAME);
         assert(weapon.IsValid(), "ERROR: Unable to find the weapon " + cWEAPON_NAME + " on the platform " + processingPlatform.Name()); 

         # Calculate pk for logging purposes
         double rangeNm = processingPlatform.SlantRangeTo(track)*Math.NM_PER_M();
         double calculatedPk = CalculateAim120Pk(rangeNm);
         string calculatedPk_s = (string)((double)((int)(calculatedPk*10000))/100.0) + "%";
         
         if(claim_check == CLAIM_ENUM_INST().NONE) {
            # This platform does not have a claim on this target. If an Intercept claim
            # was asserted previously against this target, then release that claim
            if(PCT==target && PCV==CLAIM_ENUM_INST().INTERCEPT) {
               # Transmit Release Claim
               sendClaimMessage( processingPlatform, track, CLAIM_ENUM_INST().NONE );
               # Update Platform Aux Data
               processingPlatform.SetAuxData(cG425_BMS_AUX_DATA_NAME_PCT, processingPlatform);
               processingPlatform.SetAuxData(cG425_BMS_AUX_DATA_NAME_PCV, CLAIM_ENUM_INST().NONE);
               # Update BMS SA for this platform
               GetOrCreateTargetSAForPlatform(processingPlatform, target).Set(processingPlatform, CLAIM_ENUM_INST().NONE); 
               # Update Truth
               UpdateTruthSA(processingPlatform, target, CLAIM_ENUM_INST().NONE);
               #writeln(processingPlatform.Name() + ": " + "Releasing Intercept Claim on " + target.Name());
               LogBMSEvent( processingPlatform, target, track, claim_check, "RELEASE CLAIM", "N/A" );
            }
         } else if(claim_check == CLAIM_ENUM_INST().INTERCEPT) {
            # This platform does not already have a claim, so assert an Intercept claim against this target
            # Note when a platform has no primary claim, the PCT is itself.
            if(PCT==processingPlatform) {
               # Transmit Intercept Claim
               sendClaimMessage( processingPlatform, track, CLAIM_ENUM_INST().INTERCEPT );
               # Update Platform Aux Data
               processingPlatform.SetAuxData(cG425_BMS_AUX_DATA_NAME_PCT, target);
               processingPlatform.SetAuxData(cG425_BMS_AUX_DATA_NAME_PCV, CLAIM_ENUM_INST().INTERCEPT);
               # Update BMS SA for this platform
               UpdatePlatformSA(processingPlatform, target, processingPlatform, CLAIM_ENUM_INST().INTERCEPT); 
               # Update Truth
               UpdateTruthSA(processingPlatform, target, CLAIM_ENUM_INST().INTERCEPT);
               #writeln(processingPlatform.Name() + ": " + "Tracking Intercept Claim on " + target.Name());
               LogBMSEvent( processingPlatform, target, track, claim_check, "INTERCEPT", calculatedPk_s );
            }
         } else if(claim_check == CLAIM_ENUM_INST().FIRE) {
            # This platform should fire on the given track
            if( PCV==CLAIM_ENUM_INST().NONE ||
                (PCT==target && PCV==CLAIM_ENUM_INST().INTERCEPT) ) {
               # Transmit Engage Claim
               sendClaimMessage( processingPlatform, track, CLAIM_ENUM_INST().ENGAGE );
               # Update Platform Aux Data
               processingPlatform.SetAuxData(cG425_BMS_AUX_DATA_NAME_PCT, target);
               processingPlatform.SetAuxData(cG425_BMS_AUX_DATA_NAME_PCV, CLAIM_ENUM_INST().ENGAGE);
               # Update BMS SA for this platform 
               UpdatePlatformSA(processingPlatform, target, processingPlatform, CLAIM_ENUM_INST().ENGAGE);
               # Update Truth
               UpdateTruthSA(processingPlatform, target, CLAIM_ENUM_INST().ENGAGE);
               #writeln(processingPlatform.Name() + ": " + "Firing[Engage] on " + target.Name());
               LogBMSEvent( processingPlatform, target, track, claim_check, "ENGAGE", calculatedPk_s );
            } else if ( ( weapon.QuantityRemaining() > 1 &&
                          PCV==CLAIM_ENUM_INST().INTERCEPT ) ||
                        PCV==CLAIM_ENUM_INST().ENGAGE) {
               # Transmit AoO Claim
               sendClaimMessage( processingPlatform, track, CLAIM_ENUM_INST().AOO );
               # Update BMS SA for this platform
               UpdatePlatformSA(processingPlatform, target, processingPlatform, CLAIM_ENUM_INST().AOO);
               # Update Truth
               UpdateTruthSA(processingPlatform, target, CLAIM_ENUM_INST().AOO);
               #writeln(processingPlatform.Name() + ": " + "Firing[AOO] on " + target.Name());
               LogBMSEvent( processingPlatform, target, track, claim_check, "AOO", calculatedPk_s );
            } else {
               return;
            }
            # Fire at track
            weapon.Fire(track);
         
            # If winchester RB
            if(weapon.QuantityRemaining() <= 0.0)
               processingPlatform.SetAuxData(cG425_BMS_AUX_DATA_NAME_BEHAVIOR, BEHAVIOR_ENUM_INST().RTB);
         } else {
            assert(true, "Wow, CheckClaim() somehow returned an invalid value: " + claim_check +"   - How did you even do that?"); 
         }
      }
   end_script
end_script_struct


# Global method that creates a static instance of the
# struct to attempt to treat it as a singleton.
script G425BlueBms G425BlueBmsInstance()
   static G425BlueBms bms =  G425BlueBms();
   return bms;
end_script

# Handler for the observed WEAPON_HIT or WEAPON_MISSED events
script void handleBlueWeaponEndOfLife(WsfWeaponEngagement aWeaponEngagement, WsfPlatform aTargetPlatform)
   # The blue bms only tracks blue weapons
   WsfPlatform weaponPlatform = aWeaponEngagement.WeaponPlatform();
   if(weaponPlatform.IsNull() || weaponPlatform.Side() != "blue")
      return;
   
   # Get the firing blue platform
   WsfPlatform firingPlatform = aWeaponEngagement.FiringPlatform();
   
   assert(firingPlatform.IsValid(), "handleBlueWeaponEndOfLife() - Firing platform is null. This means a weapon was in the air when its firer was destroyed ... We ened to handle this case but we currently don't");
   
   # Release all claims on this target for all platforms
   for (int i = 0; i < WsfSimulation.PlatformCount(); i = i + 1)
   {
      WsfPlatform platformToUpdate = WsfSimulation.PlatformEntry(i);
      if(platformToUpdate.IsA_TypeOf("BLUE_FIGHTER")) {
         # Release aux data
         WsfPlatform aux_target = null;
         if(platformToUpdate.CheckAuxData(cG425_BMS_AUX_DATA_NAME_PCT))
            aux_target = (WsfPlatform)platformToUpdate.AuxDataObject(cG425_BMS_AUX_DATA_NAME_PCT);
         if(aux_target == aTargetPlatform) {
            writeln_debug( (string)TIME_NOW + " Releasing Aux Data for platformToUpdate " + platformToUpdate.Name() +
                           " against target " + aux_target.Name());
            platformToUpdate.SetAuxData(cG425_BMS_AUX_DATA_NAME_PCT, platformToUpdate);
            platformToUpdate.SetAuxData(cG425_BMS_AUX_DATA_NAME_PCV, CLAIM_ENUM_INST().NONE);
         }
                  
         # Release platform SA  (should probably create an API method for this)
         writeln_debug( (string)TIME_NOW + " Updating platform" + platformToUpdate.Name() +
                        " SA for claiming platform " + firingPlatform.Name() + " against target " + aTargetPlatform.Name()); 
         G425BlueBmsInstance().UpdatePlatformSA(platformToUpdate, aTargetPlatform, firingPlatform, CLAIM_ENUM_INST().NONE);
         
         # Release truth  (should probably create an API method for this)
         writeln_debug( (string)TIME_NOW + " Updating SA truth for " + platformToUpdate.Name() +
                        " against target " + aTargetPlatform.Name());
         G425BlueBmsInstance().UpdateTruthSA(platformToUpdate, aTargetPlatform, CLAIM_ENUM_INST().NONE);
         
         G425BlueBmsInstance().LogBMSEvent( platformToUpdate, aTargetPlatform, null, "N/A", "Weapon EOL[NONE]", "N/A" );
      }
   }   
   
   aTargetPlatform.Comment("Weapon EOL with pk:" + (string)aWeaponEngagement.Pk());
end_script 

script void handleBlueWeaponFired(WsfWeaponEngagement aWeaponEngagement, WsfTrack aTargetTrack){
   string weaponName = aWeaponEngagement.WeaponSystemName();
   if(weaponName == "AIM120_MRAAM_Launcher") {
       WsfPlatform weaponPlatform = aWeaponEngagement.WeaponPlatform();
       if(weaponPlatform.AuxDataExists("CalculatedPK")){
          double calculatedPk = weaponPlatform.AuxDataDouble("CalculatedPK");
          string calculatedPk_s = (string)((double)((int)(calculatedPk*10000))/100.0) + "%";
          weaponPlatform.Comment("Pk: "+ calculatedPk_s);
       }
   }
}
end_script

script void handlePlatformBroken(WsfPlatform platform) {
   G425BlueBmsInstance().HandlePlatformDestroyed(platform);
}
end_script


# Handler for the observed SIMULATION_INITIALIZING event
script void handleSimulationInitializing() {
   CSV_DATA_TYPES csvDataTypes = CSV_DATA_TYPES();
   
   Array<string> header = {
      "Time",
      "Platform",
      "BehaviorState",
      "MissileCount",
      "TrackID",
      "TrackAge",
      "TrackPlatform",
      "Claim Against Track",
      "Decision",
      "Pk",            
      "PrimaryTarget",
      "PrimaryTargetValue",
      "Truth Claims",
      # "Transmitter",   Platform SA INFO
      # "CommsType",     Truth SA INFO
   };
   Array<string> types = {
      csvDataTypes.cDECIMAL_TYPE,
      csvDataTypes.cSTRING_TYPE,
      csvDataTypes.cSTRING_TYPE,
      csvDataTypes.cINT_TYPE,
      csvDataTypes.cSTRING_TYPE,
      csvDataTypes.cDECIMAL_TYPE,
      csvDataTypes.cSTRING_TYPE,
      csvDataTypes.cSTRING_TYPE,
      csvDataTypes.cSTRING_TYPE,
      csvDataTypes.cSTRING_TYPE,
      csvDataTypes.cSTRING_TYPE,
      csvDataTypes.cSTRING_TYPE,
      csvDataTypes.cSTRING_TYPE,
      # csvDataTypes.cSTRING_TYPE, Platform SA INFO type
      # csvDataTypes.cSTRING_TYPE, Truth SA INFO type
   };

   CSVLogFileManagerInstance().CreateLogFile(G425BlueBmsInstance().cBMS_LOG_FILE_NAME, header, types);
}
end_script

# Handler for the observed SIMULATION_STARTING event
script void handleSimulationStarting() {
   WsfBMUtils.SetInternalLoggingLevel("debug");
   
   # Set the initial bms aux data on the blue platforms
   for (int i = 0; i < WsfSimulation.PlatformCount(); i = i + 1)
   {
      WsfPlatform p = WsfSimulation.PlatformEntry(i);
            
      if(p.IsA_TypeOf("BLUE_FIGHTER")) {
         if (p.Heading() > 0 ) 
            p.SetAuxData(cG425_BMS_AUX_DATA_NAME_BEHAVIOR, BEHAVIOR_ENUM_INST().CAP_FORWARD);
         else
            p.SetAuxData(cG425_BMS_AUX_DATA_NAME_BEHAVIOR,  BEHAVIOR_ENUM_INST().CAP_BACKWARD);

         p.SetAuxData(cG425_BMS_AUX_DATA_NAME_PCT, p ); # when there is no claim, this value is the platform itself
         p.SetAuxData(cG425_BMS_AUX_DATA_NAME_PCV, CLAIM_ENUM_INST().NONE );
      }
   }
}
end_script

# script void handleWeaponEndOfLife(WsfWeaponEngagement aWeaponEngagement, WsfPlatform aTargetPlatform)
#    # Get the shooter (the aircraft that fired, not the weapon)
#    WsfPlatform shooter = aWeaponEngagement.FiringPlatform();
#    
#    # Only disengage if the shooter is still valid
#    if (shooter.IsValid() && aTargetPlatform.IsValid())
#    {
#       G425BlueBmsInstance().Disengage(shooter, aTargetPlatform);
#    }
#    
#    # Handle weapon platform cleanup separately
#    WsfPlatform weaponPlat = aWeaponEngagement.WeaponPlatform();
#    if (weaponPlat.IsValid() && weaponPlat.AuxDataExists("GlobalTrackNumber"))
#    {
#       weaponPlat.DeleteAuxData("GlobalTrackNumber");
#    }
# end_script

observer
   enable WEAPON_HIT handleBlueWeaponEndOfLife
   enable WEAPON_MISSED handleBlueWeaponEndOfLife
   enable WEAPON_FIRED handleBlueWeaponFired
   enable PLATFORM_BROKEN handlePlatformBroken
   enable SIMULATION_INITIALIZING handleSimulationInitializing
   enable SIMULATION_STARTING handleSimulationStarting
end_observer